// 1. BUSCAR estas l√≠neas (alrededor de l√≠nea 35):
// let socketServer: Server | null = null;
// let globalUserSockets: Map<string, string> = new Map();

// 2. AGREGAR estas l√≠neas DESPU√âS de las variables globales existentes:

// Tracking de usuarios activos con informaci√≥n detallada
let activeUsers = new Map<string, {
  socketId: string;
  username: string;
  userId: string;
  joinTime: Date;
  lastActivity: Date;
}>();

// Funci√≥n para broadcastear estad√≠sticas de usuarios
function broadcastUserStats() {
  if (!socketServer) return;
  
  const stats = {
    totalActive: activeUsers.size,
    users: Array.from(activeUsers.values()).map(user => ({
      username: user.username,
      userId: user.userId,
      joinTime: user.joinTime.toISOString(),
      lastActivity: user.lastActivity.toISOString(),
      duration: Math.floor((Date.now() - user.joinTime.getTime()) / 1000) // segundos conectado
    })),
    timestamp: new Date().toISOString()
  };
  
  // Emitir a todos los clientes conectados
  socketServer.emit('userStatsUpdate', stats);
  console.log(`üìä [WS] Stats broadcasting: ${stats.totalActive} usuarios activos`);
}

// 3. BUSCAR esta secci√≥n en el evento 'authenticate' (alrededor de l√≠nea 120):
// console.log(`‚úÖ [WS] ========== AUTENTICACI√ìN EXITOSA ==========`);

// 4. AGREGAR estas l√≠neas DESPU√âS de esa secci√≥n (antes de "Verificaci√≥n INMEDIATA"):

          // NUEVO: Agregar usuario a tracking activo
          activeUsers.set(userId, {
            socketId: socket.id,
            username: user.username,
            userId: userId,
            joinTime: new Date(),
            lastActivity: new Date()
          });

          // NUEVO: Broadcastear estad√≠sticas actualizadas
          broadcastUserStats();

// 5. BUSCAR la secci√≥n en el evento 'disconnect' (alrededor de l√≠nea 180):
// console.log(`üßπ [WS] Mapeos limpiados para usuario ${userId}`);

// 6. AGREGAR estas l√≠neas DESPU√âS de esa l√≠nea:

        // NUEVO: Remover usuario del tracking activo
        activeUsers.delete(userId);

        // NUEVO: Broadcastear estad√≠sticas actualizadas
        broadcastUserStats();

// 7. BUSCAR el evento 'heartbeat' existente y REEMPLAZARLO con esto:

    // Actualizar actividad del usuario en heartbeat
    socket.on('heartbeat', () => {
      const userId = connectedClients.get(socket.id);
      if (userId && activeUsers.has(userId)) {
        const userInfo = activeUsers.get(userId)!;
        userInfo.lastActivity = new Date();
        activeUsers.set(userId, userInfo);
      }
      socket.emit('heartbeat-ack', { timestamp: Date.now() });
    });

// 8. BUSCAR el setInterval del monitoreo de salud (alrededor de l√≠nea 240) y AGREGAR despu√©s del console.log de usuarios conectados:

    // Actualizar estad√≠sticas cada 30 segundos si hay cambios
    if (activeUsers.size > 0) {
      broadcastUserStats();
    }

// 9. BUSCAR el return al final de setupWebSocket y AGREGAR antes del return:

  // Broadcast inicial de estad√≠sticas cuando se inicializa
  setTimeout(() => {
    broadcastUserStats();
  }, 1000);

  // Monitoreo peri√≥dico y limpieza de usuarios inactivos cada 60 segundos
  setInterval(() => {
    const now = new Date();
    let removedUsers = 0;
    
    // Limpiar usuarios inactivos (m√°s de 2 minutos sin actividad)
    activeUsers.forEach((userInfo, userId) => {
      const inactiveTime = now.getTime() - userInfo.lastActivity.getTime();
      if (inactiveTime > 120000) { // 2 minutos
        console.log(`üßπ [WS] Removiendo usuario inactivo: ${userInfo.username}`);
        activeUsers.delete(userId);
        removedUsers++;
      }
    });
    
    if (removedUsers > 0) {
      broadcastUserStats();
    }
    
    // Log estad√≠sticas cada 60 segundos
    console.log(`üë• [WS] Usuarios activos: ${activeUsers.size}`);
    if (activeUsers.size > 0) {
      console.log(`üìã [WS] Lista de usuarios:`);
      activeUsers.forEach((userInfo) => {
        const duration = Math.floor((now.getTime() - userInfo.joinTime.getTime()) / 1000);
        console.log(`   - ${userInfo.username} (${duration}s conectado)`);
      });
    }
  }, 60000);

// 10. AGREGAR al final del archivo, antes del √∫ltimo export:

export function getActiveUsersCount(): number {
  return activeUsers.size;
}

export function getActiveUsers() {
  return Array.from(activeUsers.values());
}